# Assembler Programming Project

See the
[Assembler PP assignment](www.cs.kzoo.edu/cs230/Projects/AssemblerProj.html)
for the instructions for this assignment, coding tips, links to helpful
documents, and submission requirements.

### Importing LabelTable functions into this repository
The Assembler project builds upon the LabelTable functions you have already
written.  Before you start this project, make sure to first fix any errors
or make other changes that were suggested in the grading feedback to
LabelTable.  Don't forget to test your changes!

The next thing to do is to copy the C source files and header files from your
LabelTable project into this repository.  For example,
    cd ../LabelTable        (or whatever the directory name is)
    cp *.c *.h ../Assembler  (or whatever the name should be)
    cp smallSampleTestfile.mips ../Assembler

If you also copy the Makefile over, it will overwrite the Assembler project
Makefile that is already in this repository, but there is a copy in
AssemblerMakefile, so you can get the appropriate Makefile for this project
by typing
    cp AssemblerMakefile Makefile

Once you have copied the appropriate LabelTable files to this repository,
compile and test them again, using `make testLabelTable`.  Then add,
commit, and push them to Kit as a starting point for the Assembler.

You should also test your LabelTable code with the `testPass1` program,
especially if you didn't already do that before submitting your LabelTable
project (`make testPass1` followed by `./testPass1 smallSampleTestfile.mips`).

**Optional:**
The Makefile provided in this repository also has rules for a second test
program.  If you're interested, you can compile and run the test driver
that was written to test the getNTokens function provided to you: `make
testGetNTokens` followed by `./testGetNTokens`.

### Starting the Assembler project
Once you start working on the Assembler project itself, adjust the
`all:` target to include `assembler` (as suggested in the comments).
Alternatively, you could change it to just specify `assembler`.

Note also that the Makefile assumes that your assembler program will
include a file called `assembler.c` containing a `main` function.  The
`main` function in `testPass1.c` makes a good template for this, so a good
starting point is to copy `testPass1.c`, calling it `assembler.c`, and then
edit it to start implementing your Assembler project.  You will also have
to edit the Makefile whenever you create a new source file for the project.

A good next step, as described in the 
[Assembler PP
assignment](www.cs.kzoo.edu/cs230/Projects/AssemblerProj.html), is to
edit your `assembler.c` file and uncomment the lines near the bottom that
rewind the file back to the beginning and then call `pass2`.  If you
compile and run the program, passing it the `smallSampleTestfile.mips` file
copied from LabelTable, you will see a number of error messages and a few
lines showing you an instruction's opcode or funct code and the arguments
that appear with it.  If you add `1` to the command line to turn on
debugging, you will also see the label table generated by pass 1 and a
trace of the program attempting to determine each instruction's opcode or
funct code.

When your program is fully implemented, the `smallSampleTestfile.mips`
input file should produce output equivalent to
`smallSampleTestfile.mips.out` (which is a copy of the original
`smallSampleTestfile.input` file in the Disassembler repository).  Note,
though, that these two files only test some cases; they do not provide a
thorough test suite.

> Since comparing long strings of binary is difficult,
> you may want to use the Unix/Linux `diff` command to compare your output
> with `smallSampleTestfile.mips.out`.  To do this, you would run your
> program and save your output to a file rather than print it to the screen:
>     ./assembler smallSampleTestfile.mips &gt; myOutput
>     diff myOutput smallSampleTestfile.mips.out
> If you are running Windows, the two files might have different line endings
> (carriage return and line feed <em>vs.</em> just line feed), so you may
> want to run them through `stripCR` first.  For example,
>     make stripCR
>     ./stripCR smallSampleTestfile.mips.out &gt; strippedSmallSample.out

The provided code includes two functions that are fully implemented,
`pass2` and `getInstName`, as well as
stub versions of a number of functions called by `pass2` that you
may choose to complete or replace.  If you choose to replace them, replace
their signatures with signatures of your new functions in `assembler.h`
and add the files containing your new functions to the `assembler` target
in the `Makefile`.

The provided functions and stub functions in `pass2.c`, `getInstName.c`,
and `printAsBinary.c` include:
 - `pass2`: Reads the instruction name (first skipping over labels, if
   necessary), gets the opcode or funct code, and then calls functions
   to process the instruction, depending on the format.
 - `getInstName`: Finds the instruction name within the instruction.
 - `getOpCode`: Designed to return I- and J-format opcodes, or 0 if the
   instruction is not a valid I- or J-format instruction.
 - `getFunctCode`: Designed to return R-format funct codes, or -1 if the
   instruction is not a valid R-format instruction.
 - `printInt`: Designed to print the binary version of a value. (Stub prints
   the decimal equivalent, which is useful while developing and debugging
   the program, so you may want to keep that stub behavior until everything
   else is finished.  If you keep `printInt` in stub form, you can compare
   output against `smallSampleTestfile.mips.decimal` as you develop and test.)
 - `printReg`: Designed to find the register number for the given register and
   print its binary value (or decimal value during debugging) using `printInt`.
 - `printIntInString`: Prints the value of the integer in a string
   (e.g., "23") in binary format (or decimal format during debugging);
   fully implemented.
 - `processR`: Designed to print R-format instructions in their machine code
   format.
 - `printJumpTarget`: Designed to print an address for J-format instructions.
 - `printBranchOffset`: Designed to print a branch offset for `beq`
   and `bne` instructions.
 - `processIorJ`: Designed to print I- and J-format instructions in their
   machine code format.
These functions could be implemented in the order given above (or with
printInt implemented last).  Since they exist as stubs, it is possible to
test each function as you complete it or, in the case of processR and
processIorJ, as you complete portions. You may choose to have printInt
continue to print decimal values instead of, or in addition to, binary
values until the last minute to make debugging easier, but the final format
should be a string of 32 0's and 1's in each line, with no spaces, tabs, or
other formatting.

Following agile development principles, repeatedly Edit, Test, and Add/Commit
until the program is done. You can `git push` to Kit as often as you want.
(See the [Working with Git Repositories in
Kit](http://www.cs.kzoo.edu/CSShared/HelpFiles/Kit/RepositoryAssignments.md)
document for more information about writing a program within a Git
repository.)

Don't forget to provide a README.md file with external documentation about
your program, as described in the 
[Assembler PP assignment](www.cs.kzoo.edu/cs230/Projects/AssemblerProj.html).

### Submission
When you are ready to submit your work, click on the "Turn In"
button. (You should still be able to push further changes to Kit
after turning an assignment in if you need to.)

